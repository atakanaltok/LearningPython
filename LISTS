VREATING

letters = ["a", "b", "c"]     
matrix = [[0, 1], [1, 2]]
zeros = [0] * 5
numbers = list(range(20))


============> ACCESSING VALUES IN LISTS

k=True

omega = [44-22, k, "k","22*2", 22*2]     ===    [22, True, ‘k’, ‘22*2’, 44]


omega [:]        # Identity  ===    [22, True, ‘k’, ‘22*2’, 44]
omega [:: 1]     # Identity  ===    [22, True, ‘k’, ‘22*2’, 44]
omega [::-1]                 ===    [44, '22*2', 'k', True, 21]

======>If last number is 
positive ==> Counted from left to right (THIS IS THE DEFAULT)
negative ==> Counted from right to left


This means that when:
==> positive, the latter number must be greater than former number 

omega [:2]                   ===    [22, True]                      0 < 2
omega [2:4]                  ===    ['k', '22*2']                   3 < 5
omega [1:13]                 ===    [True, 'k', '22*2', 44]         1 < 13
omega [-5:-2]                ===    [22, True, 'k']                -5 < -2
omega [-3::2]                ===    ["k", 44]                      -3 < len(omega)
omega [-32::2]               ===    [21, 'k', 99]                 -32 < len(omega)


==> negative, the former number must be greater than latter number

omega [4::-1]                ===    [44, '22*2', 'k', True, 21]     4 > len
omega [:-100:-1]             ===    [44, '22*2', 'k', True, 21]
omega [::-2]                 ===    [44, 'k', 21]



omega [::2]                  ===    [22, "k", 44]         === omega [-len(omega)::2]

omega[len(anything):]





=========> Changing portions in list

omega[:2] = [11,101]      # Changes firs two

omega[:2] = []            # Delets first two
omega[:]  = []            # Deletes list

omega.clear()             # Deletes list


# Removing items 
letters.pop()
letters.pop(0)
letters.remove("b")
del letters[0:3]


# Finding items 
if "f" in letters: 
    letters.index("f")
 
 

# Sorting lists 
letters.sort()
letters.sort(reverse=True) 

# Custom sorting 
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 11)
]
 
items.sort(key=lambda item: item[1])
 
# Map and filter 
prices = list(map(lambda item: item[1], items))
expensive_items = list(filter(lambda item: item[1] >= 10, items))
 
# List comprehensions 
prices = [item[1] for item in items]
expensive_items = [item for item in items if item[1] >= 10]
 
# Zip function 
list1 = [1, 2, 3]
list2 = [10, 20, 30]
combined = list(zip(list1, list2))    # [(1, 10), (2, 20)]





======> Commands that are out of the rage will give blank

omega[7:] 
omega[7:13] 
omega[:13]

omega[2:-4] 
omega[::-1]




============> LISTS IN LISTS


alpha = [  [2,4,6,8], 101, "a word", ["nested", 1008, 234]  ]

a= [[“Hi”, “Hello”]]

a[0:1]                  === [[“Hi”, “Hello”]]     = a[0] but in a list
a[0:1] [0]              === [“Hi”, “Hello”]       = a[0] but pure
a[0:1] [0] [1]          === “Hello”               = a[0][1]
a[0:1] [0] [1] [1]      === e                     = a[0][1][1]





============> SOTRING


=========> Sorting with .sort

This will sort the main list

friends = ["Mulan", "Dragon", "Mushu", "Chickens"]
friends.sort()          === ["Chickens", "Dragon", "Mulan", "Mushu"]


=========> Sorting with .sorted

This will create an identical list and will sort that list, original list will not change
friends.sorted()          === 




============> ADDITION

beta  = list(range(5))                  ===       [0, 1, 2, 3, 4]
tetha = list(range(10,16))              ===       [10, 11, 12, 13, 14, 15]

beta += ["write anything"]              ===       [0, 1, 2, 3, 4, 'write anything']
beta += [100, "fun", 100]               ===       [0, 1, 2, 3, 4, 'write anything', 100, 'fun', 100]

beta += tetha                           ===       [0, 1, 2, 3, 4, 'write anything', 100, 'fun', 100, 10, 11, 12, 13, 14, 15]
# Just as in extend



=========> Adition with .extend

It extends; therefore, it takes list, tuple, string

meta  = list(range(3))
meta.extend(    [4, 5, 6]    )          ===       [1, 2, 3, 4, 5, 6]
meta.extend(tetha)                      ===       [1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15]
meta.extend("smart")                    ===       [1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, "s", "m", "a", "r", "t"]


=========> Addition with .append

It nests, therefore, it can takes any thing (list, dic, )

meta.append(    [4, 5, 6]    )          ===       [1, 2, 3, [4, 5, 6]]


meta.extend( [ 50 ] )         === meta.extend(50)            === [1, 2, 3, 50]
meta.extend( [ "smart" ] )    === meta.extend("smart")       === [1, 2, 3, "smart"]




# Looping over lists 
for letter in list: 
    ... 
 
for index, letter in enumerate(list): 
    ... 
















